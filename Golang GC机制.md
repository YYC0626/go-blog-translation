#  Golang GC机制

Go v1.3：标记-清除法，整体过程需要STW，效率极低；

Go v1.5：三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要对栈重新扫描（STW），效率普通；

Go v1.8：三色标记法，混合写屏障机制，栈空间不启动，堆空间启动，整体过程几乎不需要STW，效率极高

> ​	“几乎不需要”的意思是gc的准备阶段和结束阶段还是需要STW，耗时很小。



##  v1.3 标记-清除法

###  1.流程

1. STW（Stop The World）
2. 标记程序的可达对象
3. 未标记对象被回收
4. 结束暂停，程序继续执行
5. 循环1-4



###  2.缺点

1. STW，让程序暂停，出现卡顿；
2. 扫描整个`heap`；
3. 产生`heap`碎片；
4. 即使后来吧sweep移出了STW范围，还是效果不好。



**躲不开STW**





##  v1.5 三色标记法

白灰黑三种颜色

###  1.流程

1. 初始全白
2. 根结点出发，直接可达对象标为灰色
3. 从灰色的出发，直接可达的也变为灰色；当前已经遍历完了的灰色变为黑色
4. 继续遍历灰色集合直至没有灰色
5. 所有白色对象都回收



###  2.假如没有STW

#### 1.危险

最**不希望**发生的：

​	白色被黑色引用 && 灰色与白色的引用被清除

 后果：

​	该白色会被清除，黑色找不到该白色



#### 2.解决方法：强弱三色不变式

##### 强三色不变式：（破坏条件1）

​	强制不允许黑色引用白色。



##### 弱三色不变式：（破坏条件2）

​	黑色引用白色时必须保证有灰色也在引用该白色。



### 3.屏障机制

* 插入屏障--对象被引用时触发
* 删除屏障--对象被删除时触发

#### 插入写屏障（不在栈上使用）

##### 操作：

​		在A引用B时，B要被标记为灰色。

##### 满足：

​	强三色不变式

##### 不足：

**回收白色之前，STW，重新扫描一次栈，结束STW（STW约10~100ms）**



#### 删除写屏障

##### 操作：

被删除对象，如果自身为灰色或者白色，那么被标记为灰色。

##### 满足

​	弱三色不定式

##### 不足：

回收精度低，保护对象一轮。





##  v1.8 三色标记法 + 混合写屏障

##### 操作：

1. GC开始时扫描栈，所有栈上的对象标记为黑色（防止STW重新扫描）
2. GC期间，栈上新创建的对象均为黑色
3. 被删除的对象标记为灰色
4. 被添加的对象标记为灰色

##### 满足：

​	变形的弱三色不变式



### 常见场景

#### 场景一：

对象被一个堆对象删除引用，成为栈对象的下游

**第3条保护了该对象**



#### 场景二：

对象被一个栈对象删除引用，成为另一个栈对象的下游

**黑色对象，无需保护，若回收则下轮回收**



#### 场景三：

对象被一个堆对象删除引用，成为另一个堆对象的下游

**有可能触发第四条的保护**



#### 场景四：

对象从一个栈对象删除引用，成为另一个堆对象的下游

**有可能触发第3条**



